## 递归

函数在执行过程中一次或者多次调用本身

* 阶乘

```python
def factoria(n):
    if n == 0:
        return 1
    else:
        return n * factoria(n - 1)      #重复调用自身
```

* 二分查找

适用于有序列表的查找

维持两个参数`low` `high`，首先判断目标值和与`mid`的关系
$$
mid = [(low  + high ) /2 ]
$$
目标值 < `mid`，`high` = `mid - 1`

目标值 > `mid`，`high` = `mid + 1`

二分查找的时间复杂度是$O(log\ n)$

```python
def binary_search(data, target, low, high):
    if low > high:
        return False
    else:
        mid = (low + high) // 2
        if target == data[mid]: # low 和 high 都是data的索引
            return True
        elif target < data[mid]:
            return binary_search(data, target, low, mid - 1)
        else:
            return binary_search(data, target, mid + 1, high)
```

