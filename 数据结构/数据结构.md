# Python 数据结构

## 运行时间检测

用到python的`time`模块检测不同的累计求和算法的效率

``` {.python}
def sumOfN(n):
  start = time.time()
  theSum = 0
  for i in range(1, n + 1):
    theSum = theSum + 1
    
  end = time.time()
  return theSum, end - start


for i in range(5):
  print("Sum id %d required %f seconds" 
        % sumOfN(10000))
```

``` {.python}
Sum is 50005000 required 0.000324 seconds
Sum is 50005000 required 0.000335 seconds
Sum is 50005000 required 0.000299 seconds
Sum is 50005000 required 0.000299 seconds
Sum is 50005000 required 0.000335 seconds
```

当求和的数量级继续增加

`100000`

``` {.python}
Sum is 5000050000 required 0.010225 seconds
Sum is 5000050000 required 0.006815 seconds
Sum is 5000050000 required 0.005984 seconds
Sum is 5000050000 required 0.005179 seconds
Sum is 5000050000 required 0.004217 seconds
```

`1000000`

``` {.python}
Sum is 500000500000 required 0.050195 seconds
Sum is 500000500000 required 0.041557 seconds
Sum is 500000500000 required 0.035992 seconds
Sum is 500000500000 required 0.037516 seconds
Sum is 500000500000 required 0.036436 seconds
```

### 无迭代算法

``` {.python}
def sumOfN2(n):
  start = time.time()
  theSum = (n * (n + 1)) / 2
  end = time.time()
  return theSum, end - start
```

`10000`

``` {.python}
Sum is 50005000 required 0.000003 seconds
Sum is 50005000 required 0.000001 seconds
Sum is 50005000 required 0.000001 seconds
Sum is 50005000 required 0.000001 seconds
Sum is 50005000 required 0.000001 seconds
```

`100000`

``` {.python}
Sum is 5000050000 required 0.000003 seconds
Sum is 5000050000 required 0.000001 seconds
Sum is 5000050000 required 0.000001 seconds
Sum is 5000050000 required 0.000001 seconds
Sum is 5000050000 required 0.000001 seconds
```

无迭代算法的运行时间和输入的数的大小没有关系

## 大O表示法

### 算法时间度量指标

一个算法所实施的操作数量或者步骤数可作为独立于程序的度量指标。一个程序中，控制流语句起到组织语句的作用，而赋值语句包含了计算和存储。所以多用赋值语句衡量算法的指标

算法中，赋值语句多，时间就长。例如：

``` {.python}
def sumOfN(n):
    theSum = 0
    for i in range(1, n + 1):
        theSum = theSum + 1
    return theSum
```

赋值语句数量`T(n) = 1 + n`, 即此函数赋值语句执行的次数。

而算法分析的目标是找到问题规模怎么影响算法执行时间的

### 数量级函数

从动态的眼光来看`T(n)`中的精确值并不是特别重要，占**主导**的部分，称为**大O**表示法。

所以上面函数的运行时间数量级就是**O(n)**， 也称为算法的时间复杂度，再比如: $$
T(n) = 5n^2 + 27n + 1005
$$ 他的时间复杂度为 $$
O(n^2)
$$

而无迭代算法累计求和的的时间复杂度就是`O(1)`

### 常见的大O数量级

![](https://gitee.com/limbo1996/picgo/raw/master/png/20210315211026.png)

``` {.python}
a = 5
b = 6
c = 10

for i in range(n):
  for j in range(n):
    x = i * j
    y = j * j
    z = i * i
```

以上代码的`T(n) = 3 + 3n2`

### 变位词问题

例如`python`和`typhon`

构建函数，检测两个词是不是变位词

1.  逐字检查

    ![](https://gitee.com/limbo1996/picgo/raw/master/png/20210315212558.png)

代码实现

``` {.python}
def anargramSolution1(s1, s2):
  alist = list(s2)
  pos1 = 0
  stillOK = True
  while pos1 < len(s1) and stillOK:
    pos2 = 0
    found = False
    
    while pos2 < len(alist) and not found:
      if s1[pos1] == alist[pos2]:
        found = True
      else:
        pos2 = pos2 + 1
        
    if found:
      alist[pos2] = None
    else:
        stillOK = False
    pos1 = pos1 + 1
  return stillOK  
```

主要部分在两重循环是, 时间复杂度为`O(n2)`

2.  排序比较

    将两个字符串都按照字母的顺序排列，之后在比较是否完全相同

![](https://gitee.com/limbo1996/picgo/raw/master/png/20210315222532.png)

代码实现

``` {.python}
def anargramSolution2(s1, s2):
  alist1 = list(s1)
  alist2 = list(s2)
  
  alist1.sort()
  alist2.sort()
  
  pos = 0
  matches = True
  while pos < len(s1) and matches:
    if alist1[pos] == alist2[pos]:
      pos = pos + 1
    else:
      matches = False
  return matches
```

初看， 时间复杂度为`O(n)`， 但是程序中的`sort`的使用也同样会有代价， 这个算法的时间主导的步骤是**排序**的步骤，时间复杂度为`O(nlogn)`。

3.  暴力法

    穷尽所有的组合， 将s1全排列，看s2是否出现在其中。时间复杂度为`O(n!)`

4.  计数比较

    比较两个词中各个字母出现的次数，如果所有次数相同，就一定是变位词

    ``` {.python}
    def anargramSolution4(s1, s2):
      c1 = [0] * 26
      c2 = [0] * 26
      for i in range(len(s1)):
        pos = ord(s1[i]) - ord('a')
        c1[pos] = c1[pos] + 1
        
      for i in range(len(s2)):
        pos = ord(s2[i]) - ord('a')
        c2[pos] = c2[pos] + 1
        
      j = 0
      stillOK = True
      while j < 26 and stillOK:
        if c1[j] == c2[j]:
          j = j + 1
        else:
          stillOK = False
          
          
      return stillOK
    ```

    这里比较特殊的是第三个循环，他的循环次数是固定的26个，所以这个算法总操作次数是`T(n) = 2n + 26`, 时间复杂度为`O(n)`

## 线性结构

-   栈
-   队列
-   双端队列
-   列表

他们的区别是数据的增减先后的关系，只存在先后关系，所以是线性结构

### 栈

栈是一系列对象组成的集合，这些对象的插入和删除错遵循**先进后出**的原则。

就像向弹夹中塞子弹，最先发射的是最后一个装进去的。

-   浏览器的历史记录，最上面的是最后浏览的。
-   撤销机制， 取消的是最近的一个操作。

可以用python的**列表**来实现一个栈

列表已经支持`append`函数，用于向列表尾部压入一个元素，并且支持`pop`函数，从尾部弹出一个元素。所以列表的尾部应该是栈的栈顶，当然头部也可以，但是会比较麻烦。

当然列表与栈还是有区别的。
